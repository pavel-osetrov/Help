Мы уже упомянули MongoDB, и надо поближе познакомиться с ним. 
Это типичный пример NoSQL БД - no only sql. БД, которые не применяют SQL в качестве основного языка разработки, а также не применяют реляционную схему.

1970 год - появление РСУБД как персистентные хранилища на носителях.
Появляются нормальные формы для компактного хранения. Но при этом нормализованные данные трудны для специфических выборок. Вы уже видели сложные запросы. 

В 00-х появляются nosql. Данные хранятся в документах (в монго), схем как таковых нет (хотя можно их описывать), умеют масштабироваться из коробки, транзакций в полноценном виде нет, также нет джойнов (поэтому и применяется денормализация, чтобы получить полный список данных), консистентность могут и не поддерживать.

Монго - документоориентированное хранилище. Если сравнить с реляционными, то везде есть понятие БД, но нет схемы и таблиц (вместо них коллекции), а вместо строчек - документы. Документ - это нефиксированная структура, это очень похоже на JSON-объект (на самом деле BSON).

docker run --name my-mongo -p27017:27017 -d mongo

sudo apt install mongodb-clients - cli
https://robomongo.org/ - клиент

Чекаем команды из презы.

use test;

Есть несколько операций вставки. insert обычно считается устаревшей, хотя документация явно об этом не говорит. 

db.myCol.insertOne({"x": 1});

myCol создастся автоматически

acknowledge - подтверждение
insertedId - это уникальный идентификатор

Каждый элемент имеет поле _id

db.myCol.findOne();

writeConcern - это параметр, который можно указать для неблокирующей записи. Это означает, что наш клиент не будет дожидаться ack.

db.myCol.insertOne({"x": 1}, {writeConcern: {w: 0}});

w: 0 - сколько серверов ждём, пока не уйдём. 0 - не ждём ничего.
3 - хотя бы 3 машины из реплики

wtimeout - время ожидания для отказа от записи

Для множественной вставки можно добавлять ordered: true, который будет учитывать порядок.

Рассказать про пример с отчётами.

Рассказать про поиск. 

projection - мы выводим не весь документ, а перечисление полей для ответа

db.myCol.findOne({"_id" : ObjectId("5ce515902af323cb57c238bf")}, {"_id":1});

id показывается всегда

Параметры
eq		=
gt  	>
gte 	>=
in 		перечисление
lt 		<
lte 	<=
ne 		!=
nin 	не входит

db.test.find({$and: [{"age":30}, {"firstName":"John"}]});

Массивы
all - полное совпадение по массиву
size - соответствие массива заданному

db.test.find({"tags": {$size: 2}});

----

BSON

Конечный автомат - способ представления сколь угодно больших структур
Документ состоит из элементов e_list с окончанием "\x00" размером int32

Если мы посмотрим файл коллекции, то увидим там поток BSON-документов
Каждый элемент состоит из имени поля, типа и значения. Имена полей — это строки. Типы включают: 

    string — строка,
    int — целое число,
    double — число с плавающей запятой двойной точности,
    DateTime — дата,
    byte[] — массив байтов (бинарные данные),
    bool — булевые (True и False),
    null — «Null» (специальное значение),
    BsonObject — BSON-объект,
    BsonObject[] — массив BSON-объектов.

 ----

 Обновление

 > db.myCol.update({"x": 1}, {"x": 42});
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })

upsert - вставка, если не найден фильтр

db.myCol.update({"x": 1}, {"x": 42}, {"upsert": true});

----

inc - +1
set - полностью изменить поле
rename - переименовать поле
unset - удалить поле

push добавляется новый элемент в конец
pop убирается первый или последний
pull удаление из массива указанный 
addToSet добавить элемент

----

Aggregation pipeline
Есть набор документов, который при прохождении через пайплайн, меняется. Сортировка, добавление, удаление, маппинг.
На выходе - новая коллекция

Механизм на уровне внутренних инструментов

MapReduce
Внешняя история, на JS. Умеет работать с доками больше 16 мегабайт.

Предположим, что мы разрабатываем крупное онлайн-приложение, данные которого хранятся распределенным образом на нескольких серверах во всех уголках земного шара. Помимо всего прочего у пользователя указаны его интересы. Мы решили вычислить популярность каждого интереса путем простого определения числа пользователей, разделяющих этот интерес. Если бы мы использовали реляционную СУБД и хранили всех пользователей на одном сервере, то простой запрос с использованием операции group by помог бы нам получить ответ. В случае разных узлов мы бы хотели, чтобы эта группировка выполнялась параллельно, загружая все сервера равномерно. В мире реляционных СУБД и SQL-запросов представить такое довольно сложно, а вот с помощью Map-Reduce эта задача вполне решаема.

В ходе выполнения система выполняет над данными операции Map и Reduce, которые определяются программистом. В MongoDB эти операции имеют вид функций, написанных на Javascript. То есть сами функции пишет программист, а Mongo управляет их вызовом.

В начале к каждому документу коллекции применяется операция Map, которая формирует пары <ключ, значение>. Эти пары затем передаются функции reduce в сгруппированном по ключу виде. Операция Reduce формирует одну пару <ключ, значение>. Как в качестве ключа, так и в качестве значения могут выступать любые переменные, включая объекты.